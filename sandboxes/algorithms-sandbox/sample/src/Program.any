#pragma region Task
#include <iostream>
#include <vector>

using namespace std;

long long module = 1000000007;

class matrix
{
	vector<vector<long long>> values;

	static int count_matrix_value(const matrix& first, const matrix& second, int column, int row)
	{
		auto value = 0ll;
		for (auto i = 0; i < first.get_width(); i++)
		{
			value += first.get(row, i) * second.get(i, column);
			value %= module;
		}

		return value;
	}

public:
	explicit matrix(vector<vector<long long>> values)
	{
		this->values = move(values);
	}

	long long get(const int x, const int y) const
	{
		return values[x][y];
	}

	int get_width() const
	{
		return values[0].size();
	}

	int get_height() const
	{
		return values.size();
	}

	matrix operator* (const matrix& another) const
	{
		auto new_vector = vector<vector<long long>>(this->get_height());

		for (auto& vector_in : new_vector)
		{
			vector_in = vector<long long>(another.get_width());
		}

		for (auto i = 0; i < this->get_height(); i++)
			for (auto j = 0; j < another.get_width(); j++)
			{
				new_vector[i][j] = count_matrix_value(*this, another, j, i);
			}

		return matrix(new_vector);
	}
};

matrix binpow(const matrix& matrix, long long n)
{
	if (n == 1)
		return matrix;

	if ((n & 1) == 1)
		return binpow(matrix, n - 1) * matrix;

	const auto b = binpow(matrix, n >> 1);
	return b * b;
}

matrix get_1_matrix(const int size)
{
	auto values = vector<vector<long long>>(size);
	for (auto i = 0; i < size; i++)
	{
		values[i] = vector<long long>(size);
		values[i][i] = 1;
	}

	return matrix(values);
}

matrix matrix_pow(const matrix& matrix, const long long n)
{
	return n == 0 ? get_1_matrix(matrix.get_width()) : binpow(matrix, n);
}

int main()
{
    long long a0, d, b0, q, n;
    std::cin >> a0 >> d >> b0 >> q >> n;

	const auto r_matrix = matrix(
		{
					{ 1, 1, 0 },
					{ 0, q, d * q },
					{ 0, 0, q }
		});

	const auto m = matrix(r_matrix);
	const auto p_matrix = matrix_pow(m, n - 1);

	const auto vector_m = matrix(
		{
				{ a0 * b0 },
				{ (a0 + d) * b0 * q },
				{ b0 * q }
		});

	const auto res = p_matrix * vector_m;
	
	std::cout << res.get(0, 0) << std::endl;
    return 0;
}
#pragma endregion Task